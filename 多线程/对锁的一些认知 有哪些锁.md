# 同一进程

##重入锁

使用ReentrantLock获取锁的时候会判断当前线程是否为获取锁的线程，如果是则将同步的状态+1，释放锁的时候则将状态-1.只有将同步状态的次数置为0的时候才会最终释放锁。

##读写锁

使用ReentrantReadWriteLock，同时维护一对锁：读锁和写锁。当写线程访问时则其他所有锁都将阻塞，读线程访问时则不会。通过读写锁的分离可以很大程度的提高并发量和吞吐量。

# 不同进程

分布式锁：

## 基于数据库

可以创建一张表，将其中的某个字段设置为唯一索引，当多个请求过来的时候只有新建记录成功的请求才算获取到锁，当使用完毕删除这条记录的时候即释放锁。

存在的问题：

+ 数据库单点问题，挂了怎么办？
+ 不是重入锁，一旦insert失败则会立即返回，并不会进入阻塞队列只能下一次在获取。
+ 

